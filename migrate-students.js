// Load environment variables
require("dotenv").config();

const { Client, Databases, ID } = require("node-appwrite");

// Initialize Appwrite client
const client = new Client()
  .setEndpoint(process.env.NEXT_PUBLIC_APPWRITE_ENDPOINT)
  .setProject(process.env.NEXT_PUBLIC_APPWRITE_PROJECT_ID)
  .setKey(process.env.APPWRITE_API_KEY); // You'll need to add this to your .env

const databases = new Databases(client);

// Collection IDs
const databaseId = process.env.NEXT_PUBLIC_APPWRITE_DATABASE_ID;
const oldCollectionId = "students_new";
let newCollectionId = null; // Will be auto-generated by Appwrite

async function migrateStudents() {
  try {
    console.log("Starting student data migration...");

    // Validate environment variables
    const requiredEnvVars = {
      NEXT_PUBLIC_APPWRITE_ENDPOINT: process.env.NEXT_PUBLIC_APPWRITE_ENDPOINT,
      NEXT_PUBLIC_APPWRITE_PROJECT_ID:
        process.env.NEXT_PUBLIC_APPWRITE_PROJECT_ID,
      NEXT_PUBLIC_APPWRITE_DATABASE_ID:
        process.env.NEXT_PUBLIC_APPWRITE_DATABASE_ID,
        APPWRITE_API_KEY: process.env.APPWRITE_API_KEY,
    };

    const missingVars = Object.entries(requiredEnvVars)
      .filter(([key, value]) => !value)
      .map(([key]) => key);

    if (missingVars.length > 0) {
      console.error("‚ùå Missing required environment variables:");
      missingVars.forEach((varName) => console.error(`   - ${varName}`));
      console.error("\nPlease add these to your .env file and try again.");
      process.exit(1);
    }

    console.log("‚úÖ All environment variables are set");
    console.log("Database ID:", databaseId);
    console.log("Old Collection ID:", oldCollectionId);
    console.log("New Collection ID: Will be auto-generated by Appwrite");

    // Step 1: Create the new collection with auto-generated ID
    console.log("\n1. Creating new collection with auto-generated ID...");
    let newCollection;
    try {
      newCollection = await databases.createCollection(
        databaseId,
        ID.unique(), // Let Appwrite auto-generate the collection ID
        "Student Collection"
      );
      newCollectionId = newCollection.$id; // Store the auto-generated ID
      console.log("‚úÖ New collection created with ID:", newCollectionId);
    } catch (error) {
      throw error;
    }

    // Step 2: Create attributes for the new collection
    console.log("\n2. Creating collection attributes...");
    const attributes = [
      { key: "studentId", type: "string", required: true },
      { key: "lastName", type: "string", required: true },
      { key: "firstName", type: "string", required: true },
      { key: "middleName", type: "string", required: false },
      { key: "school", type: "string", required: true },
      { key: "year", type: "string", required: true },
      { key: "age", type: "string", required: true },
      { key: "sex", type: "string", required: true },
      { key: "orientation", type: "string", required: false },
      { key: "religion", type: "string", required: false },
      { key: "address", type: "string", required: true },
      { key: "ethnicGroup", type: "string", required: false },
      { key: "firstGen", type: "string", required: false },
      { key: "createdBy", type: "string", required: true },
      { key: "isArchived", type: "boolean", required: false, default: false },
      { key: "academicPeriodId", type: "string", required: false },
      { key: "eventId", type: "string", required: false },
      { key: "section", type: "string", required: false },
    ];

    for (const attr of attributes) {
      try {
        if (attr.type === "string") {
          await databases.createStringAttribute(
            databaseId,
            newCollectionId,
            attr.key,
            attr.required ? 255 : 0,
            attr.required,
            attr.default
          );
        } else if (attr.type === "boolean") {
          await databases.createBooleanAttribute(
            databaseId,
            newCollectionId,
            attr.key,
            attr.required,
            attr.default
          );
        }
        console.log(`‚úÖ Created attribute: ${attr.key}`);
      } catch (error) {
        if (error.code === 409) {
          console.log(`‚ö†Ô∏è Attribute ${attr.key} already exists`);
        } else {
          console.error(
            `‚ùå Error creating attribute ${attr.key}:`,
            error.message
          );
        }
      }
    }

    // Step 3: Fetch all documents from old collection
    console.log("\n3. Fetching data from old collection...");
    let allDocuments = [];
    let offset = 0;
    const limit = 100;

    while (true) {
      const response = await databases.listDocuments(
        databaseId,
        oldCollectionId,
        [],
        limit,
        offset
      );

      allDocuments = [...allDocuments, ...response.documents];

      if (response.documents.length < limit) {
        break;
      }

      offset += limit;
      console.log(`üìÑ Fetched ${allDocuments.length} documents so far...`);
    }

    console.log(`‚úÖ Total documents to migrate: ${allDocuments.length}`);

    // Step 4: Migrate documents to new collection
    console.log("\n4. Migrating documents to new collection...");
    let successCount = 0;
    let errorCount = 0;
    const errors = [];

    for (let i = 0; i < allDocuments.length; i++) {
      const doc = allDocuments[i];

      try {
        // Prepare document data (remove Appwrite internal fields)
        const { $id, $createdAt, $updatedAt, $permissions, ...documentData } =
          doc;

        // Create document in new collection
        await databases.createDocument(
          databaseId,
          newCollectionId,
          ID.unique(),
          documentData
        );

        successCount++;

        if ((i + 1) % 10 === 0) {
          console.log(`‚úÖ Migrated ${i + 1}/${allDocuments.length} documents`);
        }
      } catch (error) {
        errorCount++;
        errors.push({
          originalId: doc.$id,
          error: error.message,
          data: documentData,
        });
        console.error(`‚ùå Error migrating document ${doc.$id}:`, error.message);
      }

      // Add a small delay to prevent rate limiting
      await new Promise((resolve) => setTimeout(resolve, 100));
    }

    // Step 5: Summary
    console.log("\n5. Migration Summary:");
    console.log(`‚úÖ Successfully migrated: ${successCount} documents`);
    console.log(`‚ùå Failed migrations: ${errorCount} documents`);
    console.log(`üÜî New Collection ID: ${newCollectionId}`);

    if (errors.length > 0) {
      console.log("\n‚ùå Errors encountered:");
      errors.forEach((error, index) => {
        console.log(
          `${index + 1}. Document ${error.originalId}: ${error.error}`
        );
      });
    }

    // Step 6: Verify migration
    console.log("\n6. Verifying migration...");
    const newCollectionCount = await databases.listDocuments(
      databaseId,
      newCollectionId
    );

    console.log(`üìä Old collection count: ${allDocuments.length}`);
    console.log(`üìä New collection count: ${newCollectionCount.total}`);

    if (newCollectionCount.total === allDocuments.length) {
      console.log("‚úÖ Migration verification successful!");
    } else {
      console.log("‚ö†Ô∏è Migration verification failed - counts do not match");
    }

    console.log("\nüéâ Migration completed!");
    console.log(
      "\nIMPORTANT: Update your appwrite.js file with the new collection ID:"
    );
    console.log(`export const studentCollectionId = "${newCollectionId}";`);
    console.log("\nNext steps:");
    console.log(
      "1. Update your appwrite.js file with the new collection ID above"
    );
    console.log("2. Test your application with the new collection");
    console.log(
      "3. Delete the old collection once everything is confirmed working"
    );

    // Save the new collection ID to a file for easy reference
    const fs = require("fs");
    const configData = {
      newCollectionId: newCollectionId,
      migrationDate: new Date().toISOString(),
      oldCollectionId: oldCollectionId,
      documentCount: successCount,
    };

    fs.writeFileSync(
      "migration-config.json",
      JSON.stringify(configData, null, 2)
    );
    console.log("\nüìÑ Migration configuration saved to migration-config.json");
  } catch (error) {
    console.error("‚ùå Migration failed:", error);
    process.exit(1);
  }
}

// Run the migration
migrateStudents();
